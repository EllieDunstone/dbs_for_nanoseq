---
title: "DBS call correction"
author: "Ellie Dunstone"
date: "2023-02-25"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load packages, include=FALSE}
library(tidyverse)
library(deconstructSigs)
library(spgs)
```

## Introduction

This script uses the trinucleotide frequencies present in your NanoSeq data (output by the NanoSeq pipeline) to calculate the dinucleotide frequencies present, and then use these values to correct your matrix of observed DBS counts (see "dnv_caller.Rmd") according to the dinucleotide frequency in your data. This effectively maps your observed calls onto the frequency that would be expected in a normal diploid human genome.

## Read in data

First, we want to read in our DBS mutation matrix. This script assumes that this is in the format generated by dnv_caller.Rmd ("MutationType" as column 1, followed by one column per sample of counts for each mutation class).

```{r set work dir}
work.dir <- "/Users/ed4/Documents/phd/chemo_project/BotSeq/panbody/panbody_20230106/"
```

```{r read in dbs matrix}
dbs_matrix <- read.table(paste0(work.dir,"data/dbs_mutation_matrix.tsv"), header = TRUE)
```

We also need to read in and format the observed trinucleotide frequencies for our data, as calculated by the NanoSeq pipeline (ratio2genome files).

```{r read in ratio2genome files}
#list file names
files <- list.files(path = paste0(work.dir, "data/dbs_calling/ratio2genome/"), pattern = "*.tsv$")

#read in as tables
for (file in files) {
  temp <- read.table(paste0(work.dir, "data/dbs_calling/ratio2genome/", file), sep="\t", header = TRUE)
  temp <- cbind(trinuc = rownames(temp), data.frame(temp, row.names=NULL))
  assign(file, temp)
}

#add sample ID as column
tables <- c()

for (file in files) {
  new <- mutate(get(file), sampleID = paste0(strsplit(file, "_")[[1]][1], "_", strsplit(file, "_")[[1]][2]))
  assign(paste0("sampleID_", file), new)
  tables <- cbind(tables, paste0("sampleID_", file))
}

#concatenate tables
trinuc_ratio2genome_table <- data.frame(matrix(ncol=ncol(new))) #init table
colnames(trinuc_ratio2genome_table) <- colnames(new)

for (table in tables) {
  trinuc_ratio2genome_table <- rbind(trinuc_ratio2genome_table, get(table))
  print(table)
}

trinuc_ratio2genome_table <- trinuc_ratio2genome_table[-1,] #drop blank first row
```

Finally, we need the frequencies of trinucleotides present in the human genome. This can be obtained from the package 'deconstructSigs'.

```{r read in genome dinuc freqs}
genome_trinuc_freqs <- deconstructSigs::tri.counts.genome
genome_trinuc_freqs <- cbind(rownames(genome_trinuc_freqs), data.frame(genome_trinuc_freqs, row.names=NULL))
colnames(genome_trinuc_freqs) <- c("trinuc", "freq")
```


## Calculate dinucleotide frequencies

Now we have the data for our observed trinucleotide frequencies and those in the human genome, we can use this to calculate the dinucleotide frequencies. We can do this by summing the counts of trinucleotides, ignoring the 'third' base. For example, we can sum the counts for CTA, CTC, CTT and CTG to give the count for CT.

```{r calculate observed dinuc freq}
#calculate for dinucs given
dinuc_ratio2genome_table <- trinuc_ratio2genome_table %>% select(trinuc, tri_bg, sampleID) %>% mutate(dinuc = substr(trinuc, 1, 2)) %>% group_by(sampleID, dinuc) %>% summarise(dinuc_count = sum(tri_bg)) 
```

```{r calculate genome dinuc freq}
genome_dinuc_freqs <- genome_trinuc_freqs %>% mutate(dinuc = substr(trinuc, 1, 2)) %>% group_by(dinuc) %>% summarise(genome_dinuc_count = sum(freq))
```


## Calculate ratio between observed dinucleotide frequencies and genome frequencies

Using these data, we can now calculate the ratio between the observed dinucleotide proportions in our data and the proportions in the human genome.

```{r calculate dinuc ratio2genome}
dinuc_ratio2genome_table <- dinuc_ratio2genome_table %>% left_join(genome_dinuc_freqs) %>% mutate(obs_prop = dinuc_count/sum(dinuc_count)) %>% mutate(exp_prop = genome_dinuc_count/sum(genome_dinuc_count)) %>% mutate(dinuc_ratio2genome = obs_prop/exp_prop)
```


## Calculate dinucleotide burdens and corrected dinucleotide mutation counts

We can use these values to generate estimated dinucleotide burdens and corrected dinucleotide mutation counts, as done by the NanoSeq pipeline for single base substitutions. 

To generate a corrected dbs matrix, we multiply the rows of our existing matrix by the ratios calculated above.

We also need to consider here that the frequencies (and therefore correction factors) for nucleotides that are the reverse complements of each other are the same.

```{r correct dbs matrix}
###make matrix of correction factors for your data

##init df
correction_factors <- as.data.frame(matrix(nrow = nrow(dbs_matrix), ncol = ncol(dbs_matrix)))
correction_factors[,1] <- substr(dbs_matrix$MutationType, 1, 2)
colnames(correction_factors) <- c("dinuc", colnames(dbs_matrix)[-1])

##make reverse complement table
rev_comp <- as.data.frame(cbind(dinuc = unique(dinuc_ratio2genome_table$dinuc), dinuc_rc = spgs::reverseComplement(unique(dinuc_ratio2genome_table$dinuc), case = "as is")))


##add corresponding correction factors for each sample and dinuc context

#for each cell of the table
for (i in 2:ncol(correction_factors)) {
  for (j in 1:nrow(correction_factors)) { 
    #if ratio calculated for dinuc
    if (correction_factors$dinuc[j] %in% rev_comp$dinuc) { 
      #look up ratio using dinuc and sampleID and assign to table
      correction_factors[j, i] <- dinuc_ratio2genome_table$dinuc_ratio2genome[which(dinuc_ratio2genome_table$dinuc == correction_factors$dinuc[j] & dinuc_ratio2genome_table$sampleID == colnames(correction_factors)[i])] 
    } else { 
      #if not, look up reverse complement
      rc <- rev_comp$dinuc[which(rev_comp$dinuc_rc == correction_factors$dinuc[j])] 
      #look up ratio using dinuc reverse complement and sampleID and assign to table
      correction_factors[j, i] <- dinuc_ratio2genome_table$dinuc_ratio2genome[which(dinuc_ratio2genome_table$dinuc == rc & dinuc_ratio2genome_table$sampleID == colnames(correction_factors)[i])] 
    }
  }
}


# some of the dinucleotides still aren't in here and i'm confused and upset. If you are reading this on my github then please stop, don't look at me :( 

#correct dbs matrix by multiplying by correction factors
dbs_matrix_corrected <- cbind(dbs_matrix[,1], dbs_matrix[,-1]*correction_factors)
colnames(dbs_matrix_corrected) <- colnames(dbs_matrix)
```


Need to now work out what to do next - how is this used to generate the 'burdens' and 'trint_onto_genome' files for the SBS?

Creating the 'mut_burden.tsv' file - for each sample, has columns 'muts, total, burden, burden_lci, burden_uci' and then rows 'observed, corrected' - we essentially only need the 'corrected' row for downstream analysis.

Pretty sure the observed and corrected total are the same, so it's just the muts that need correcting? 


results.trint_subs_obs_corrected.tsv file contains the trinucleotide mutation type, the trint_subst_obs (observed number of this kind of mutation), and 'trint_onto_genome'. Presumably regardless of the mut type, you use the ratio for the frequency of the ref? 

Do you then use the sum of trint_onto_genome per sample to calculate the corrected genome burden for the burdens file as above?

I'm a bit confused about how this ties into correcting for the duplex coverage per sample? Need to think about it more.

